//! Virt-viewer (.vv) file importer.
//!
//! Parses `.vv` files generated by libvirt/Proxmox VE for SPICE and VNC
//! connections. These INI-style files contain a `[virt-viewer]` section
//! with connection parameters like host, port, TLS settings, and proxy.
//!
//! Reference: <https://manpages.debian.org/testing/virt-viewer/remote-viewer.1.en.html>

use std::collections::HashMap;
use std::path::{Path, PathBuf};

use secrecy::SecretString;

use crate::error::ImportError;
use crate::models::{
    Connection, Credentials, PasswordSource, ProtocolConfig, SpiceConfig, VncConfig,
};

use super::traits::{read_import_file, ImportResult, ImportSource, SkippedEntry};

/// Importer for virt-viewer `.vv` connection files.
///
/// Supports SPICE and VNC connection types as defined by the
/// virt-viewer file format used by libvirt, Proxmox VE, and oVirt.
pub struct VirtViewerImporter;

impl Default for VirtViewerImporter {
    fn default() -> Self {
        Self::new()
    }
}

impl VirtViewerImporter {
    /// Creates a new virt-viewer importer
    #[must_use]
    pub const fn new() -> Self {
        Self
    }

    /// Parses INI-style content into key-value pairs for the
    /// `[virt-viewer]` section.
    fn parse_vv_section(content: &str) -> Option<HashMap<String, String>> {
        let mut in_section = false;
        let mut fields = HashMap::new();

        for line in content.lines() {
            let line = line.trim();

            if line.is_empty() || line.starts_with('#') || line.starts_with(';') {
                continue;
            }

            if line.eq_ignore_ascii_case("[virt-viewer]") {
                in_section = true;
                continue;
            }

            // Another section starts — stop
            if line.starts_with('[') && line.ends_with(']') {
                if in_section {
                    break;
                }
                continue;
            }

            if in_section {
                if let Some(eq_pos) = line.find('=') {
                    let key = line[..eq_pos].trim().to_lowercase();
                    let value = line[eq_pos + 1..].trim().to_string();
                    fields.insert(key, value);
                }
            }
        }

        if fields.is_empty() {
            None
        } else {
            Some(fields)
        }
    }

    /// Converts parsed virt-viewer fields into a `Connection`.
    fn convert_to_connection(
        fields: &HashMap<String, String>,
        source_path: &str,
        result: &mut ImportResult,
    ) -> Option<Connection> {
        // Determine protocol type
        let proto = fields
            .get("type")
            .map(|s| s.to_lowercase())
            .unwrap_or_default();

        let (protocol_config, default_port) = match proto.as_str() {
            "spice" => {
                let tls_port = fields.get("tls-port").and_then(|p| p.parse::<u16>().ok());
                let has_tls = tls_port.is_some();

                let ca_cert_path = fields.get("ca").and_then(|ca| {
                    // The CA is inline PEM — we cannot map it to a file path
                    // directly. Warn the user so they know TLS may fail.
                    if ca.starts_with("-----BEGIN") {
                        result.add_skipped(SkippedEntry::with_location(
                            source_path,
                            "Inline PEM CA certificate cannot be imported automatically. \
                             Save it to a file and set the CA path in connection settings.",
                            source_path,
                        ));
                        None
                    } else {
                        Some(PathBuf::from(ca))
                    }
                });

                // Store proxy URL in SpiceConfig so it's used for connections
                let proxy = fields.get("proxy").filter(|p| !p.is_empty()).cloned();

                (
                    ProtocolConfig::Spice(SpiceConfig {
                        tls_enabled: has_tls,
                        ca_cert_path,
                        proxy,
                        ..SpiceConfig::default()
                    }),
                    default_port_for_spice(fields),
                )
            }
            "vnc" => (ProtocolConfig::Vnc(VncConfig::default()), 5900u16),
            "" => {
                result.add_skipped(SkippedEntry::with_location(
                    source_path,
                    "Missing 'type' field in [virt-viewer] section",
                    source_path,
                ));
                return None;
            }
            other => {
                result.add_skipped(SkippedEntry::with_location(
                    source_path,
                    format!("Unsupported virt-viewer type: {other}"),
                    source_path,
                ));
                return None;
            }
        };

        // Extract host
        let host = match fields.get("host") {
            Some(h) if !h.is_empty() => h.clone(),
            _ => {
                result.add_skipped(SkippedEntry::with_location(
                    source_path,
                    "No host specified in [virt-viewer] section",
                    source_path,
                ));
                return None;
            }
        };

        // Extract port: prefer tls-port for SPICE, then port
        let port = fields
            .get("tls-port")
            .and_then(|p| p.parse::<u16>().ok())
            .or_else(|| fields.get("port").and_then(|p| p.parse::<u16>().ok()))
            .unwrap_or(default_port);

        // Build connection name from title or host
        let name = fields
            .get("title")
            .filter(|t| !t.is_empty())
            .cloned()
            .unwrap_or_else(|| format!("{host}:{port}"));

        let mut conn = Connection::new(name, host, port, protocol_config);

        // Handle password — store as credential, mark source as Vault
        if let Some(pw) = fields.get("password").filter(|p| !p.is_empty()) {
            conn.password_source = PasswordSource::Vault;
            let creds = Credentials {
                username: None,
                password: Some(SecretString::from(pw.clone())),
                key_passphrase: None,
                domain: None,
            };
            result.credentials.insert(conn.id, creds);
        }

        // Store host-subject as a tag for reference
        if let Some(subj) = fields.get("host-subject").filter(|s| !s.is_empty()) {
            conn.tags.push(format!("host-subject:{subj}"));
        }

        conn.tags.push("imported:virt-viewer".to_string());

        Some(conn)
    }
}

/// Returns the appropriate default port for a SPICE connection
/// based on whether TLS is configured.
fn default_port_for_spice(fields: &HashMap<String, String>) -> u16 {
    fields
        .get("tls-port")
        .and_then(|p| p.parse::<u16>().ok())
        .or_else(|| fields.get("port").and_then(|p| p.parse::<u16>().ok()))
        .unwrap_or(5900)
}

impl ImportSource for VirtViewerImporter {
    fn source_id(&self) -> &'static str {
        "virt_viewer"
    }

    fn display_name(&self) -> &'static str {
        "Virt-Viewer (.vv)"
    }

    fn is_available(&self) -> bool {
        // File-based import — always available
        true
    }

    fn default_paths(&self) -> Vec<PathBuf> {
        // No default paths — user selects the file
        Vec::new()
    }

    fn import(&self) -> Result<ImportResult, ImportError> {
        Err(ImportError::FileNotFound(PathBuf::from(
            "No default paths for virt-viewer files. Use import_from_path().",
        )))
    }

    fn import_from_path(&self, path: &Path) -> Result<ImportResult, ImportError> {
        let content = read_import_file(path, "virt-viewer")?;
        let source_path = path.display().to_string();

        let mut result = ImportResult::new();

        let Some(fields) = Self::parse_vv_section(&content) else {
            return Err(ImportError::ParseError {
                source_name: "virt-viewer".to_string(),
                reason: "No [virt-viewer] section found in file".to_string(),
            });
        };

        if let Some(conn) = Self::convert_to_connection(&fields, &source_path, &mut result) {
            result.add_connection(conn);
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn write_vv_file(content: &str) -> NamedTempFile {
        let mut f = NamedTempFile::new().expect("tempfile");
        f.write_all(content.as_bytes()).expect("write");
        f.flush().expect("flush");
        f
    }

    #[test]
    fn test_parse_spice_proxmox() {
        let content = "\
[virt-viewer]
type=spice
host=pvespiceproxy:6991bb86:207:nuc::19b918cb428c22c74b6099263598d66d
tls-port=61000
password=secret123
title=VM 200 - test
proxy=http://192.168.1.100:3128
host-subject=OU=PVE Cluster Node,O=Proxmox Virtual Environment,CN=nuc.example.org
delete-this-file=1
toggle-fullscreen=Shift+F11
release-cursor=Ctrl+Alt+R
secure-attention=Ctrl+Alt+Ins
ca=-----BEGIN CERTIFICATE-----\\nMIIFake...
";
        let f = write_vv_file(content);
        let importer = VirtViewerImporter::new();
        let result = importer.import_from_path(f.path()).expect("import");

        assert_eq!(result.connections.len(), 1);
        let conn = &result.connections[0];
        assert_eq!(conn.name, "VM 200 - test");
        assert_eq!(conn.port, 61000);
        assert!(matches!(
            conn.protocol_config,
            ProtocolConfig::Spice(ref s) if s.tls_enabled
        ));
        assert_eq!(conn.password_source, PasswordSource::Vault);
        assert!(result.credentials.contains_key(&conn.id));
        // Proxy should be stored in SpiceConfig, not as a tag
        assert!(matches!(
            conn.protocol_config,
            ProtocolConfig::Spice(ref s) if s.proxy.as_deref() == Some("http://192.168.1.100:3128")
        ));
        assert!(conn.tags.iter().any(|t| t.starts_with("host-subject:")));
        // Inline PEM CA should produce a skipped entry warning
        assert!(
            result
                .skipped
                .iter()
                .any(|s| s.reason.contains("Inline PEM")),
            "Expected skipped entry for inline PEM CA certificate"
        );
    }

    #[test]
    fn test_parse_vnc() {
        let content = "\
[virt-viewer]
type=vnc
host=192.168.1.50
port=5901
title=My VNC VM
";
        let f = write_vv_file(content);
        let importer = VirtViewerImporter::new();
        let result = importer.import_from_path(f.path()).expect("import");

        assert_eq!(result.connections.len(), 1);
        let conn = &result.connections[0];
        assert_eq!(conn.name, "My VNC VM");
        assert_eq!(conn.port, 5901);
        assert!(matches!(conn.protocol_config, ProtocolConfig::Vnc(_)));
    }

    #[test]
    fn test_missing_section() {
        let content = "just some random text\nno section here\n";
        let f = write_vv_file(content);
        let importer = VirtViewerImporter::new();
        let err = importer.import_from_path(f.path()).unwrap_err();
        assert!(matches!(err, ImportError::ParseError { .. }));
    }

    #[test]
    fn test_missing_host() {
        let content = "\
[virt-viewer]
type=spice
tls-port=61000
";
        let f = write_vv_file(content);
        let importer = VirtViewerImporter::new();
        let result = importer.import_from_path(f.path()).expect("import");
        assert!(result.connections.is_empty());
        assert_eq!(result.skipped.len(), 1);
    }

    #[test]
    fn test_unsupported_type() {
        let content = "\
[virt-viewer]
type=rdp
host=example.com
port=3389
";
        let f = write_vv_file(content);
        let importer = VirtViewerImporter::new();
        let result = importer.import_from_path(f.path()).expect("import");
        assert!(result.connections.is_empty());
        assert_eq!(result.skipped.len(), 1);
    }

    #[test]
    fn test_name_fallback_to_host_port() {
        let content = "\
[virt-viewer]
type=spice
host=10.0.0.1
port=5900
";
        let f = write_vv_file(content);
        let importer = VirtViewerImporter::new();
        let result = importer.import_from_path(f.path()).expect("import");
        assert_eq!(result.connections[0].name, "10.0.0.1:5900");
    }
}
